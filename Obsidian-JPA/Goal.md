JPA + Spring DATA + QueryDSL

제일 먼저 JPA에 국한되서 일어나는 일을 정리해 준다.

JPA 도입 이전에 Domain 중심 설계까지의 철학을.. 그리고 이게 비지니스 성공에 어떻게 연결되는지..

내가 JPA 도입한 이유.
- 프로그램에서 가장 복잡하고 가장 변화가 많은 곳은 비지니스 도메인이 있는 곳.
- JPA는 Table 작성이 프로그램 개발의 일부이면서 복잡도를 증가시키던 요인에서(sql 오류, 변경) 
	- 상수로 변경 시켜 주었다.
- 그래서 개발자는 비지니스 도메인에 집중할 수 있게 되었고, 이를 통해 기능이 기능이 풍부하면서도 빠른 개발이 가능하게 되었다.

어려웠던 이유
- 헤깔리는 @JoinColumn with Direction
	- 이로 인해 파생되는 성능 이슈
- 해결책 : 패턴 별 정리. 샘플을 보관한다. 만들 때 참고한다.

내가 복잡도를 제어하는 방식은 깊은 이해를 바탕으로 패턴을 정리하고 이 샘플을 가지고 응용해서 문제를 푼다는 거구만... 이건 회사랑 비슷하네.

지금은 샘플작성, 그리고 응용 문제 해결이다.


객체 세상과 저장의 세상은 다르다...
1-1. 불일치 문제 (Domain Layer vs persistence Layer)
- Object World와 Persistence World의 차이.
- Table을 만들고 이를 호출하는 Controller를 만들고 CRUD 테스트 vs
- 비지니스 도메인을 깊게 이해하고 도메인간의 관계를 설정하고 이 흐름이 유기적으로 잘 흐르도록 유지하는 것. 나머지는 상수화(자동화)
- 첫 질문이 Table이 어떻게 되는가?를 물어보는게 아니라 비지니스 도메인이 어떻게 되는지 비지니스의 이해가 선행되는 방향으로 개발 패턴이 변경
- JPA를 도입하므로서 데이터 베이스와 객체간의 매핑하는데 시간이 획기적으로 감소
- 이는 적은 비용으로 많은 것을 할 수 있게 되는 것이고 이제는 이 시간을 비지니스에 대한 이해를 충분히 함으로서 보다 사업적 성공과 긴밀하게 할 수 있게 되는 방향으로 진화하는 것이다.
1-2. Domain Layer(Object World)에 집중하기
- 왜 도메인 모델에 집중하는가? 프로그램 복잡도 감소
- 프로그램의 규칙을 정하고


1-3. 프로그램 복잡도의 정의
	- 프로그램 복잡도 감소
	- 인지 과부화 문제를 해결.
	- 수정 및 변경 대응에 쉬어야 한다.

JPA를 실전 도입에 주저하는 이유.
- 학습 예제의 함정!
	- 실전에서는 어떻게 쓰지? (학습 코드를 보여주고.. 그래서 뭐?)
	- 지금 하던 일에서 뭐가 더 좋아지지?
		- 일의 정의를 바꿔야 한다.
			- Table First vs Domain First
				- Table이 나와서 화면을 매핑하는 개념.
				- 비지니스 Flow(개념 설계)를 먼저 하고 저장(Persistenace)을 최적화 한다.
					- 개념 설계는 Waterfall이 아니라 Iteration이다. 
					- 그러므로 개념 설계를 최적화 한뒤에 Table을 확정 짓는다.
					- Table을 하는게 좋을지 NoSQL, MongoDB등 다른 것들로 최적화 할 수 있다.

